import { readFileSync, writeFileSync } from "node:fs";
import { resolve } from "node:path";
import Anthropic from "@anthropic-ai/sdk";
import {
	extractLottieColors,
	extractPrimaryColor,
	recolorLottie,
	validateColorMap,
	validateCss,
	validateLottie,
} from "@scripts/theme-utils";
import * as Sentry from "@sentry/node";
import type { TNotionData } from "@shared/notion";

Sentry.init({ dsn: process.env.SENTRY_DSN });

const NOTION_DATA_PATH = resolve(
	import.meta.dirname,
	"../data/notion-pages.json",
);
const CAT_BASE_PATH = resolve(import.meta.dirname, "../app/data/cat-blue.json");
const PUBLIC_DIR = resolve(import.meta.dirname, "../public");
const APP_DATA_DIR = resolve(import.meta.dirname, "../app/data");
const GENERATED_CSS_PATH = resolve(
	import.meta.dirname,
	"../app/generated-themes.css",
);
const THEMES_JSON_PATH = resolve(APP_DATA_DIR, "themes.json");

// ─── Main ─────────────────────────────────────────────────────────────────────

try {
	const notionData: TNotionData = JSON.parse(
		readFileSync(NOTION_DATA_PATH, "utf-8"),
	);
	const favorites = notionData.projects.filter((p) => p.isFavorite);

	if (favorites.length === 0) {
		console.log("No favorite projects found. Writing empty outputs.");
		writeFileSync(
			GENERATED_CSS_PATH,
			"/* No favorites — generated by generate-themes.ts */\n",
		);
		writeFileSync(THEMES_JSON_PATH, "[]\n");
		await Sentry.flush(2000);
		process.exit(0);
	}

	const catBase = JSON.parse(readFileSync(CAT_BASE_PATH, "utf-8"));
	const catHexSet = extractLottieColors(catBase);
	const catHexList = Array.from(catHexSet);
	const catHexListStr = catHexList.join(", ");

	console.log(
		`Extracted ${catHexList.length} unique colors from cat-blue.json`,
	);

	const client = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });

	const cssBlocks: string[] = [];
	const themesMetadata: { slug: string; primaryColor: string }[] = [];

	for (const project of favorites) {
		console.log(`\nGenerating theme for: ${project.title} (${project.slug})`);

		try {
			if (!project.iconPath) {
				console.warn(`  No icon for "${project.slug}", skipping.`);
				continue;
			}

			const imagePath = resolve(PUBLIC_DIR, `.${project.iconPath}`);
			let imageBuffer: Buffer;
			try {
				imageBuffer = readFileSync(imagePath);
			} catch {
				console.warn(`  Icon not found at ${imagePath}, skipping.`);
				continue;
			}

			const base64Image = imageBuffer.toString("base64");
			const ext = project.iconPath.split(".").pop()?.toLowerCase() ?? "png";
			const mediaType =
				ext === "jpg" || ext === "jpeg"
					? "image/jpeg"
					: ext === "gif"
						? "image/gif"
						: ext === "webp"
							? "image/webp"
							: "image/png";

			const prompt = `You are a color palette designer. Analyze this project icon and generate a cohesive CSS theme for slug "${project.slug}".

Return ONLY a JSON object with two keys:
1. "css" — the full [data-theme="${project.slug}"] { ... } block containing exactly these 8 variables: --theme-primary, --theme-text, --theme-text-light, --theme-button, --theme-button-hover, --theme-muted, --theme-credit, --theme-blob-opacity (0.03–0.15 float).
2. "catColorMap" — an object mapping each of these existing cat hex colors ${catHexListStr} to its closest equivalent in your generated palette. Every original hex must appear as a key.

Do not include any explanation, markdown, or code fences — output raw JSON only.`;

			const response = await client.messages.create({
				model: "claude-opus-4-6",
				max_tokens: 1024,
				messages: [
					{
						role: "user",
						content: [
							{
								type: "image",
								source: {
									type: "base64",
									media_type: mediaType,
									data: base64Image,
								},
							},
							{
								type: "text",
								text: prompt,
							},
						],
					},
				],
			});

			const rawText =
				response.content[0].type === "text" ? response.content[0].text : "";

			// Strip any accidental markdown code fences
			const jsonText = rawText
				.replace(/^```(?:json)?\s*/i, "")
				.replace(/\s*```\s*$/, "")
				.trim();

			let parsed: { css: string; catColorMap: Record<string, string> };
			try {
				parsed = JSON.parse(jsonText);
			} catch (err) {
				throw new Error(
					`Failed to parse Claude response JSON for "${project.slug}": ${err}\nRaw: ${rawText}`,
				);
			}

			if (typeof parsed.css !== "string") {
				throw new Error(
					`Claude response missing "css" string for "${project.slug}"`,
				);
			}
			if (
				!parsed.catColorMap ||
				typeof parsed.catColorMap !== "object" ||
				Array.isArray(parsed.catColorMap)
			) {
				throw new Error(
					`Claude response missing "catColorMap" object for "${project.slug}"`,
				);
			}

			validateCss(parsed.css, project.slug);
			validateColorMap(parsed.catColorMap, catHexList, project.slug);

			// Recolor Lottie
			const recolored = recolorLottie(catBase, parsed.catColorMap);
			validateLottie(recolored, project.slug);

			const catOutputPath = resolve(APP_DATA_DIR, `cat-${project.slug}.json`);
			writeFileSync(catOutputPath, JSON.stringify(recolored, null, 2));
			console.log(`  Wrote ${catOutputPath}`);

			cssBlocks.push(parsed.css);
			themesMetadata.push({
				slug: project.slug,
				primaryColor: extractPrimaryColor(parsed.css),
			});
		} catch (err) {
			Sentry.captureException(err);
			throw err;
		}
	}

	// Write generated-themes.css
	const cssOutput = [
		"/* Generated by generate-themes.ts — do not edit manually */",
		"",
		...cssBlocks,
	].join("\n");
	writeFileSync(GENERATED_CSS_PATH, cssOutput);
	console.log(`\nWrote app/generated-themes.css`);

	// Write themes.json
	writeFileSync(THEMES_JSON_PATH, JSON.stringify(themesMetadata, null, 2));
	console.log(`Wrote app/data/themes.json`);
} catch (err) {
	Sentry.captureException(err);
	await Sentry.flush(2000);
	console.error(err);
	process.exit(1);
}

await Sentry.flush(2000);
console.log("\nDone.");
console.log("\nDone.");
console.log("\nDone.");
